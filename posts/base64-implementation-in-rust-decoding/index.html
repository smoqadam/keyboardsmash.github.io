<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Base64 implementation in Rust - Part 2: decoding | Saeed's Blog</title><meta name=keywords content="rust"><meta name=description content="In the previous article, we explored how base64 encoding works and successfully implemented it in Rust. Now, let&rsquo;s delve into the process of decoding a base64-encoded string. It is important to note that the implementations discussed here are primarily for educational purposes, and for production environments, it is recommended to employ well-established libraries.
Theory Here are the steps to decode a base64-encoded string:
Split the string into groups of 4 characters."><meta name=author content="Saeed"><link rel=canonical href=https://keyboardsmash.dev/posts/base64-implementation-in-rust-decoding/><link href=/assets/css/stylesheet.min.8d754ccb970fef4a6d8e5b0441e01d76a0d3530c6777067a1b2ca581aa1b4af7.css integrity="sha256-jXVMy5cP70ptjlsEQeAddqDTUwxndwZ6GyylgaobSvc=" rel="preload stylesheet" as=style><link rel=icon href=https://keyboardsmash.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://keyboardsmash.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://keyboardsmash.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://keyboardsmash.dev/apple-touch-icon.png><link rel=mask-icon href=https://keyboardsmash.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-PD18QTF1JJ","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Base64 implementation in Rust - Part 2: decoding"><meta property="og:description" content="In the previous article, we explored how base64 encoding works and successfully implemented it in Rust. Now, let&rsquo;s delve into the process of decoding a base64-encoded string. It is important to note that the implementations discussed here are primarily for educational purposes, and for production environments, it is recommended to employ well-established libraries.
Theory Here are the steps to decode a base64-encoded string:
Split the string into groups of 4 characters."><meta property="og:type" content="article"><meta property="og:url" content="https://keyboardsmash.dev/posts/base64-implementation-in-rust-decoding/"><meta property="article:published_time" content="2023-05-25T11:53:33+02:00"><meta property="article:modified_time" content="2023-05-25T11:53:33+02:00"><meta property="og:site_name" content="Saeed's blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Base64 implementation in Rust - Part 2: decoding"><meta name=twitter:description content="In the previous article, we explored how base64 encoding works and successfully implemented it in Rust. Now, let&rsquo;s delve into the process of decoding a base64-encoded string. It is important to note that the implementations discussed here are primarily for educational purposes, and for production environments, it is recommended to employ well-established libraries.
Theory Here are the steps to decode a base64-encoded string:
Split the string into groups of 4 characters."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://keyboardsmash.dev/posts/"},{"@type":"ListItem","position":3,"name":"Base64 implementation in Rust - Part 2: decoding","item":"https://keyboardsmash.dev/posts/base64-implementation-in-rust-decoding/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Base64 implementation in Rust - Part 2: decoding","name":"Base64 implementation in Rust - Part 2: decoding","description":"In the previous article, we explored how base64 encoding works and successfully implemented it in Rust. Now, let\u0026amp;rsquo;s delve into the process of decoding a base64-encoded string. …","keywords":["rust"],"articleBody":"In the previous article, we explored how base64 encoding works and successfully implemented it in Rust. Now, let’s delve into the process of decoding a base64-encoded string. It is important to note that the implementations discussed here are primarily for educational purposes, and for production environments, it is recommended to employ well-established libraries.\nTheory Here are the steps to decode a base64-encoded string:\nSplit the string into groups of 4 characters. Find the index of each character in the base64 character map. Convert each index into binary. Combine all the binaries in a group into one binary, resulting in 24 bits. Split the binary into groups of 8 bits, which correspond to characters in the ASCII table. These steps will enable us to successfully decode the base64-encoded string.\nLet’s apply these steps to decode the string UnVzdA== which we encoded in the previous article.\nSplit the string into groups of 4 bytes and find index of eaach character in the base64 table: Compine the binary and then split them into three groups of 8 bits Convert every 8 bits into a corresponding character from the ASCII table We do the same steps for the rest of the string. Note that in our example there are two padding characters, which we ignore them.\nImplementation Here is the implementation in Rust:\npub fn decode(input: \u0026[u8]) -\u003e String { let mut output: Vec\u003cu8\u003e = Vec::new(); for chunk in input.chunks(4) { let a = decode_char(chunk[0]); let b = decode_char(chunk[1]); let c = decode_char(chunk[2]); let d = decode_char(chunk[3]); let dec1 = ((a \u003c\u003c 2) | (b \u0026 0x30) \u003e\u003e 4) as u8; let dec2 = (((b \u0026 0x0F) \u003c\u003c 4) | (c \u0026 0x3C) \u003e\u003e 2) as u8; let dec3 = (((c \u0026 0x03) \u003c\u003c 6) | (d)) as u8; output.push(dec1); output.push(dec2); output.push(dec3); } String::from_utf8(output).unwrap().replace(\"\\0\", \"\") } fn decode_char(input: u8) -\u003e u8 { BASE_CHARS.iter().position(|\u0026c| c == input).unwrap_or(0) as u8 } for chunk in input.chunks(4) To begin the decoding process, we start by dividing the input into groups of 4 bytes.\nWithin the decode_char function, we locate the corresponding index of each character in the base64 character table and then return the index value. This step allows us to map each character to its appropriate index during the decoding process. During the decoding process, we ignore paddings and other characters that are not present in the base64 character map.\nlet dec1 = ((a \u003c\u003c 2) | (b \u0026 0x30) \u003e\u003e 4) as u8;\nStarting with a = 'U', we shift the binary representation of a two times to the left:\n(a \u003c\u003c 2) =\u003e (01010100 \u003c\u003c 2) =\u003e (01010000)\nFor b = 'n', we first apply a bitwise AND operation with 0x30 (which is binary 110000) to remove the last four bits of b:\n(b \u0026 0x30) =\u003e (100111 \u0026 110000) =\u003e (100000)\nThen, we shift the result four times to the right:\n(b \u0026 0x30) \u003e\u003e 4 =\u003e (100000 \u003e\u003e 4) =\u003e (000010)\nNext, we combine the results from step 1 and step 2 using the bitwise OR operation:\n(01010000 | 000010) =\u003e (01010010)\nlet dec2 = (((b \u0026 0x0F) \u003c\u003c 4) | (c \u0026 0x3C) \u003e\u003e 2) as u8;:\nStarting with b = 'n', we first apply a bitwise AND operation with 0x0F (which is binary 001111) to remove the first two bits of b:\n(b \u0026 0x0F) =\u003e (100111 \u0026 001111) =\u003e (000111)\nThen, we shift the result four times to the left:\n((b \u0026 0x0F) \u003c\u003c 4) =\u003e (000111 \u003c\u003c 4) =\u003e (01110000)\nFor c = 'V', we first apply a bitwise AND operation with 0x3C (which is binary 111100) to retrieve the last four bits of c:\n(c \u0026 0x3C) =\u003e (010101 \u0026 111100) =\u003e (010100)\nThen, we shift the result two times to the right:\n((c \u0026 0x3C) \u003e\u003e 2) =\u003e (010100 \u003e\u003e 2) =\u003e (00000101)\nNext, we combine the results from step 1 and step 2 using the bitwise OR operation:\n(((b \u0026 0x0F) \u003c\u003c 4) | (c \u0026 0x3C) \u003e\u003e 2) =\u003e (01110000 | 00000101) =\u003e (01110101)\nlet dec3 = (((c \u0026 0x03) \u003c\u003c 6) | (d)) as u8;\nStarting with c = ‘V’, we first apply a bitwise AND operation with 0x03 (which is binary 000011) to retrieve the last two bits of c:\n(c \u0026 0x03) =\u003e (010101 \u0026 000011) =\u003e (000001)\nThen, we shift the result six times to the left:\n((c \u0026 0x03) \u003c\u003c 6) =\u003e (000001 \u003c\u003c 6) =\u003e (01000000)\nFor d = 'z', we simply use the value of d as it is.\nNext, we combine the results from step 1 and the value of d using the bitwise OR operation:\n(((c \u0026 0x03) \u003c\u003c 6) | d) =\u003e (01000000 | 110011) =\u003e (01110011)\nTesting Now let’s write some tests:\n#[cfg(test)] mod tests { use super::*; #[test] fn test_decode() { let decoded = decode(b\"WW91IGFyZSBhbGxvd2VkIHRvIGJlIGJvdGggYSBtYXN0ZXJwaWVjZSBhbmQgYSB3b3JrIGluIHByb2dyZXNzLCBzaW11bHRhbmVvdXNseS4=\"); assert_eq!(\"You are allowed to be both a masterpiece and a work in progress, simultaneously.\", decoded); } } And the result:\nrunning 1 test test base64::tests::test_decode ... ok test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s Summary In the two blog posts, we learned how to do Base64 encoding and decoding and applied it in Rust. I think it’s a great way to learn a new programming language because we can challenge ourselves by combining it with other things we’re not familiar with. It makes learning more fun and productive.\n","wordCount":"900","inLanguage":"en","datePublished":"2023-05-25T11:53:33+02:00","dateModified":"2023-05-25T11:53:33+02:00","author":{"@type":"Person","name":"Saeed"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://keyboardsmash.dev/posts/base64-implementation-in-rust-decoding/"},"publisher":{"@type":"Organization","name":"Saeed's Blog","logo":{"@type":"ImageObject","url":"https://keyboardsmash.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://keyboardsmash.dev accesskey=h title="Saeed's Blog (Alt + H)">Saeed's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://keyboardsmash.dev/about title=About><span>About</span></a></li><li><a href=https://keyboardsmash.dev/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Base64 implementation in Rust - Part 2: decoding</h1><div class=post-meta>May 25, 2023&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Saeed</div></header><div class=post-content><p>In the previous article, we explored how base64 encoding works and successfully implemented it in Rust. Now, let&rsquo;s delve into the process of decoding a base64-encoded string. It is important to note that the implementations discussed here are primarily for educational purposes, and for production environments, it is recommended to employ well-established libraries.</p><h2 id=theory>Theory<a hidden class=anchor aria-hidden=true href=#theory>#</a></h2><p>Here are the steps to decode a base64-encoded string:</p><ul><li>Split the string into groups of 4 characters.</li><li>Find the index of each character in the base64 character map.</li><li>Convert each index into binary.</li><li>Combine all the binaries in a group into one binary, resulting in 24 bits.</li><li>Split the binary into groups of 8 bits, which correspond to characters in the ASCII table.</li></ul><p>These steps will enable us to successfully decode the base64-encoded string.</p><p>Let&rsquo;s apply these steps to decode the string <code>UnVzdA==</code> which we encoded in the previous article.</p><ol><li>Split the string into groups of 4 bytes and find index of eaach character in the base64 table:</li></ol><p><img src=/img/base64/decoding/1.png alt="step one"></p><ol><li>Compine the binary and then split them into three groups of 8 bits</li></ol><p><img src=/img/base64/decoding/2.png alt="step one"></p><ol><li>Convert every 8 bits into a corresponding character from the ASCII table</li></ol><p><img src=/img/base64/decoding/3.png alt="step one"></p><p>We do the same steps for the rest of the string. Note that in our example there are two padding characters, which we ignore them.</p><h2 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h2><p>Here is the implementation in Rust:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>decode</span>(input: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u8</span>]) -&gt; String {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> output: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> chunk <span style=color:#66d9ef>in</span> input.chunks(<span style=color:#ae81ff>4</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    	<span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> decode_char(chunk[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>    	<span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> decode_char(chunk[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>    	<span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> decode_char(chunk[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    	<span style=color:#66d9ef>let</span> d <span style=color:#f92672>=</span> decode_char(chunk[<span style=color:#ae81ff>3</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    	<span style=color:#66d9ef>let</span> dec1 <span style=color:#f92672>=</span> ((a <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>|</span> (b <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x30</span>) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>4</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>;
</span></span><span style=display:flex><span>    	<span style=color:#66d9ef>let</span> dec2 <span style=color:#f92672>=</span> (((b <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x0F</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>4</span>) <span style=color:#f92672>|</span> (c <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x3C</span>) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>;
</span></span><span style=display:flex><span>    	<span style=color:#66d9ef>let</span> dec3 <span style=color:#f92672>=</span> (((c <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x03</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>6</span>) <span style=color:#f92672>|</span> (d)) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    	output.push(dec1);
</span></span><span style=display:flex><span>    	output.push(dec2);
</span></span><span style=display:flex><span>    	output.push(dec3);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	String::from_utf8(output).unwrap().replace(<span style=color:#e6db74>&#34;\0&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>decode_char</span>(input: <span style=color:#66d9ef>u8</span>) -&gt; <span style=color:#66d9ef>u8</span> {
</span></span><span style=display:flex><span>	BASE_CHARS.iter().position(<span style=color:#f92672>|&amp;</span>c<span style=color:#f92672>|</span> c <span style=color:#f92672>==</span> input).unwrap_or(<span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>for chunk in input.chunks(4)</code></li></ul><p>To begin the decoding process, we start by dividing the input into groups of 4 bytes.</p><ul><li><p>Within the <code>decode_char</code> function, we locate the corresponding index of each character in the base64 character table and then return the index value. This step allows us to map each character to its appropriate index during the decoding process. During the decoding process, we ignore paddings and other characters that are not present in the base64 character map.</p></li><li><p><strong><code>let dec1 = ((a &lt;&lt; 2) | (b & 0x30) >> 4) as u8;</code></strong></p><ol><li><p>Starting with <code>a = 'U'</code>, we shift the binary representation of <code>a</code> two times to the left:</p><p><code>(a &lt;&lt; 2) => (01010100 &lt;&lt; 2) => (01010000)</code></p></li><li><p>For <code>b = 'n'</code>, we first apply a bitwise AND operation with <code>0x30</code> (which is binary 110000) to remove the last four bits of <code>b</code>:</p><p><code>(b & 0x30) => (100111 & 110000) => (100000)</code></p></li><li><p>Then, we shift the result four times to the right:</p><p><code>(b & 0x30) >> 4 => (100000 >> 4) => (000010)</code></p></li><li><p>Next, we combine the results from step 1 and step 2 using the bitwise <code>OR</code> operation:</p><p><code>(01010000 | 000010) => (01010010)</code></p></li></ol></li><li><p><code>let dec2 = (((b & 0x0F) &lt;&lt; 4) | (c & 0x3C) >> 2) as u8;</code>:</p><ol><li><p>Starting with <code>b = 'n'</code>, we first apply a bitwise <code>AND</code> operation with <code>0x0F</code> (which is binary 001111) to remove the first two bits of <code>b</code>:</p><p><code>(b & 0x0F) => (100111 & 001111) => (000111)</code></p></li><li><p>Then, we shift the result four times to the left:</p><p><code>((b & 0x0F) &lt;&lt; 4) => (000111 &lt;&lt; 4) => (01110000)</code></p></li><li><p>For <code>c = 'V'</code>, we first apply a bitwise AND operation with <code>0x3C</code> (which is binary 111100) to retrieve the last four bits of <code>c</code>:</p><p><code>(c & 0x3C) => (010101 & 111100) => (010100)</code></p></li><li><p>Then, we shift the result two times to the right:</p><p><code>((c & 0x3C) >> 2) => (010100 >> 2) => (00000101)</code></p></li><li><p>Next, we combine the results from step 1 and step 2 using the bitwise <code>OR</code> operation:</p><p><code>(((b & 0x0F) &lt;&lt; 4) | (c & 0x3C) >> 2) => (01110000 | 00000101) => (01110101)</code></p></li></ol></li><li><p><code>let dec3 = (((c & 0x03) &lt;&lt; 6) | (d)) as u8;</code></p><ol><li><p>Starting with c = &lsquo;V&rsquo;, we first apply a bitwise AND operation with 0x03 (which is binary 000011) to retrieve the last two bits of c:</p><p><code>(c & 0x03) => (010101 & 000011) => (000001)</code></p></li><li><p>Then, we shift the result six times to the left:</p><p><code>((c & 0x03) &lt;&lt; 6) => (000001 &lt;&lt; 6) => (01000000)</code></p></li><li><p>For <code>d = 'z'</code>, we simply use the value of d as it is.</p></li><li><p>Next, we combine the results from step 1 and the value of d using the bitwise OR operation:</p><p><code>(((c & 0x03) &lt;&lt; 6) | d) => (01000000 | 110011) => (01110011)</code></p></li></ol></li></ul><h2 id=testing>Testing<a hidden class=anchor aria-hidden=true href=#testing>#</a></h2><p>Now let&rsquo;s write some tests:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>super</span>::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> 	<span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_decode</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> decoded <span style=color:#f92672>=</span> decode(<span style=color:#e6db74>b&#34;WW91IGFyZSBhbGxvd2VkIHRvIGJlIGJvdGggYSBtYXN0ZXJwaWVjZSBhbmQgYSB3b3JrIGluIHByb2dyZXNzLCBzaW11bHRhbmVvdXNseS4=&#34;</span>);
</span></span><span style=display:flex><span>        assert_eq!(<span style=color:#e6db74>&#34;You are allowed to be both a masterpiece and a work in progress, simultaneously.&#34;</span>, decoded);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And the result:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>running <span style=color:#ae81ff>1</span> test
</span></span><span style=display:flex><span>test base64::tests::test_decode ... ok
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test result: ok. <span style=color:#ae81ff>1</span> passed; <span style=color:#ae81ff>0</span> failed; <span style=color:#ae81ff>0</span> ignored; <span style=color:#ae81ff>0</span> measured; <span style=color:#ae81ff>0</span> filtered out; finished in 0.00s
</span></span></code></pre></div><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>In the two blog posts, we learned how to do Base64 encoding and decoding and applied it in Rust. I think it&rsquo;s a great way to learn a new programming language because we can challenge ourselves by combining it with other things we&rsquo;re not familiar with. It makes learning more fun and productive.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://keyboardsmash.dev/tags/rust/>rust</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://keyboardsmash.dev>Saeed's Blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById("menu").scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById("menu").scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>