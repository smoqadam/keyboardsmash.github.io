<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Base64 Implementation in Rust - Part 1: encoding | Saeed's Blog</title><meta name=keywords content="rust"><meta name=description content="I&rsquo;ve been learning Rust on and off for quite a some time and every time I pick it up again I learn something new. A few days ago when I came back to it again, I was looking for a educational project to do and I decided to implement the Base64 algorithm in Rust. In this post, I will explain how to encode data to base64 in Rust. Decoding from base64 will be covered in a separate blog post, but it&rsquo;s worth practicing by implementing it yourself."><meta name=author content="Saeed"><link rel=canonical href=https://keyboardsmash.dev/posts/implementing-base64-algorithm-in-rust/><link href=/assets/css/stylesheet.min.8d754ccb970fef4a6d8e5b0441e01d76a0d3530c6777067a1b2ca581aa1b4af7.css integrity="sha256-jXVMy5cP70ptjlsEQeAddqDTUwxndwZ6GyylgaobSvc=" rel="preload stylesheet" as=style><link rel=icon href=https://keyboardsmash.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://keyboardsmash.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://keyboardsmash.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://keyboardsmash.dev/apple-touch-icon.png><link rel=mask-icon href=https://keyboardsmash.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-PD18QTF1JJ","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Base64 Implementation in Rust - Part 1: encoding"><meta property="og:description" content="I&rsquo;ve been learning Rust on and off for quite a some time and every time I pick it up again I learn something new. A few days ago when I came back to it again, I was looking for a educational project to do and I decided to implement the Base64 algorithm in Rust. In this post, I will explain how to encode data to base64 in Rust. Decoding from base64 will be covered in a separate blog post, but it&rsquo;s worth practicing by implementing it yourself."><meta property="og:type" content="article"><meta property="og:url" content="https://keyboardsmash.dev/posts/implementing-base64-algorithm-in-rust/"><meta property="article:published_time" content="2023-05-16T20:02:58+02:00"><meta property="article:modified_time" content="2023-05-16T20:02:58+02:00"><meta property="og:site_name" content="Saeed's blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Base64 Implementation in Rust - Part 1: encoding"><meta name=twitter:description content="I&rsquo;ve been learning Rust on and off for quite a some time and every time I pick it up again I learn something new. A few days ago when I came back to it again, I was looking for a educational project to do and I decided to implement the Base64 algorithm in Rust. In this post, I will explain how to encode data to base64 in Rust. Decoding from base64 will be covered in a separate blog post, but it&rsquo;s worth practicing by implementing it yourself."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://keyboardsmash.dev/posts/"},{"@type":"ListItem","position":3,"name":"Base64 Implementation in Rust - Part 1: encoding","item":"https://keyboardsmash.dev/posts/implementing-base64-algorithm-in-rust/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Base64 Implementation in Rust - Part 1: encoding","name":"Base64 Implementation in Rust - Part 1: encoding","description":"I\u0026amp;rsquo;ve been learning Rust on and off for quite a some time and every time I pick it up again I learn something new. A few days ago when I came back to it again, I was looking …","keywords":["rust"],"articleBody":"I’ve been learning Rust on and off for quite a some time and every time I pick it up again I learn something new. A few days ago when I came back to it again, I was looking for a educational project to do and I decided to implement the Base64 algorithm in Rust. In this post, I will explain how to encode data to base64 in Rust. Decoding from base64 will be covered in a separate blog post, but it’s worth practicing by implementing it yourself. I’ll share the resources I used at the end of this post.\nUseful links: Rust Book\nWhat is Base64?\nTheory Now, let’s dive into the theoretical aspects of how base64 works. By the end of this section, we’ll be able to manually encode data to base64 using pen and paper.\nThe steps to encode a set of characters to base64 are as follows:\nSplit the input, typically a sequence of bytes, into groups of three bytes. Each group of three bytes corresponds to a total of 24 bits. Split the 24 bits into four 6-bit groups. Map each 6-bit group to its corresponding base64 character from the character set: A-Z, a-z, 0-9, +, and /. If the number of bytes is not divisible by three, add the padding character ‘=’. Let’s illustrate this process by manually converting the text ‘Rust’ into base64.\nSplit the input into groups of three bytes: In the next step, we combine the binary values and split them into four 6-bit groups: Now, let’s map each group to its corresponding character using the standard base64 character mapping based on RFC4648 (image from Wikipedia): The base64 output for ‘Rus’ is as follows: Next, we continue the same steps for the remaining text. In our case, the only character left is ’t’, which would be encoded as follows: Note that if the last group doesn’t have enough bits, we fill it with 0s until it reaches 6 bits in length.\nAdding padding:\nSo far, our output is UnVzdA, but because it’s not divisible by 3, we need to add the padding character = until it becomes divisible by three.\nTo calculate how many paddings we need, use the following formula:\nr = len(input) % 3 if r is equal to 1: we need to add two paddings if r is equal to 2: we need to add one padding if r is equal to 0: no paddings needed Since the 4 % 3 = 1 we need to add two paddings at the end and the final output would be UnVzdA==.\nNow that we understand the manual conversion process, let’s implement these steps in Rust.\nImplementation: We’ll start by creating a function called encode in a file named base64.rs that takes a series of bytes as input and returns the encoded output as a string:\n// file base64.rs fn encode(input: \u0026[u8]) -\u003e String { const BASE_CHARS: \u0026[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; let mut output = Vec::new(); let input_len = input.len(); for i in (0..input_len).step_by(3) { let a = input.get(i).unwrap(); let b = input.get(i + 1).unwrap_or(\u00260); let c = input.get(i + 2).unwrap_or(\u00260); let enc1 = (a \u003e\u003e 2) as usize; let enc2 = (((a \u0026 0x3) \u003c\u003c 4) | (b \u003e\u003e 4)) as usize; let enc3 = (((b \u0026 0xf) \u003c\u003c 2) | (c \u003e\u003e 6)) as usize; let enc4 = (c \u0026 0x3f) as usize; output.push(BASE_CHARS[enc1]); output.push(BASE_CHARS[enc2]); output.push(BASE_CHARS[enc3]); output.push(BASE_CHARS[enc4]); } let output_len = output.len(); let padding_len = match input_len % 3 { 1 =\u003e 2, // Add two padding 2 =\u003e 1, // Add one paddings _ =\u003e 0, // No paddings needed }; for i in 0..padding_len { output[output_len - 1 - i] = b'='; } String::from_utf8(output).unwrap() } In the for loop we retrieve the first three byte of the input. Note that the first index is always present but the second and thrid index might be missing. That’s why we used unwrap_or(\u00260). For each group, we perform the necessary bitwise operations to obtain the corresponding base64 characters.\nIn the line let enc1 = (a \u003e\u003e 2) as usize;, we use the right shift operator (») to remove the last two bits (MSB) from the variable a. The binary representation of character R is 01010010 and by shifting it two times to the right the result is: 010100\nin the next line let enc2 = (((a \u0026 0x3) \u003c\u003c 4) | (b \u003e\u003e 4)) as usize;, first we extract the last two bits of a by \u0026ing it with 0x3 (11 in binary), then shift it four times to left and combine the value with first four bits of b. The enc2 has the value of 100111\nThen we have let enc3 = (((b \u0026 0xf) \u003c\u003c 2) | (c \u003e\u003e 6)) as usize; which extracts the last four bits of b, shift it two times to right and combine the result with first two bits of c which gives us the values of 010101\nand finally, let enc4 = (c \u0026 0x3f) as usize; which extracts the remaining bytes from c by \u0026ing it with 0x3f (1111 in binary). The enc4 is equal to 110011 in binary.\nAt the end of the for loop we obtain the corresponding base64 characters from BASE_CHARS and push it to output vector.\nWe are not done yet, we need to check if the padding is necessary or not:\nlet output_len = output.len(); let padding_len = match input_len % 3 { 1 =\u003e 2, // Add two padding 2 =\u003e 1, // Add one paddings _ =\u003e 0, // No paddings needed }; for i in 0..padding_len { output[output_len - 1 - i] = b'='; } This section of the code determines the number of padding characters required and adds them to the end of the output.\nTesting Let’s write some test to test our algorithm.\n#[cfg(test)] mod tests { use super::*; #[test] fn test_encode() { let encoded = encode(b\"Rust\"); assert_eq!(\"UnVzdA==\", encoded); } #[test] fn encode_has_padding() { let encoded = encode(b\"Rust\"); assert!(encoded.ends_with(\"==\")); } } and the result:\nrunning 2 tests test base64::tests::encode_has_padding ... ok test base64::tests::test_encode ... ok test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s Summary In this post, we achieved two goals simultaneously: understanding the base64 encoding algorithm and gained knowledge about Rust. For me, the step_by function, bitwise operators, and unwrap_or method were particularly new and useful. You can use these resources, or any others you prefer, to learn more about base64 and Rust. It’s a great exercise to try implementing the base64 decoding algorithm.\nresources http://www.sunshine2k.de/articles/coding/base64/understanding_base64.html\nhttps://en.wikibooks.org/wiki/Algorithm_Implementation/Miscellaneous/Base64#Javascript_2\nhttps://www.rapidtables.com/convert/number/hex-to-binary.html\nhttps://en.wikipedia.org/wiki/Base64\nhttps://base64.guru/learn/base64-algorithm/encode\nChatGPT\n","wordCount":"1098","inLanguage":"en","datePublished":"2023-05-16T20:02:58+02:00","dateModified":"2023-05-16T20:02:58+02:00","author":{"@type":"Person","name":"Saeed"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://keyboardsmash.dev/posts/implementing-base64-algorithm-in-rust/"},"publisher":{"@type":"Organization","name":"Saeed's Blog","logo":{"@type":"ImageObject","url":"https://keyboardsmash.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://keyboardsmash.dev accesskey=h title="Saeed's Blog (Alt + H)">Saeed's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://keyboardsmash.dev/about title=About><span>About</span></a></li><li><a href=https://keyboardsmash.dev/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Base64 Implementation in Rust - Part 1: encoding</h1><div class=post-meta>May 16, 2023&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Saeed</div></header><div class=post-content><p>I&rsquo;ve been learning Rust on and off for quite a some time and every time I pick it up again I learn something new. A few days ago when I came back to it again, I was looking for a educational project to do and I decided to implement the Base64 algorithm in Rust. In this post, I will explain how to encode data to base64 in Rust. <a href=https://keyboardsmash.dev/posts/base64-implementation-in-rust-decoding/>Decoding from base64 will be covered in a separate blog post</a>, but it&rsquo;s worth practicing by implementing it yourself. I&rsquo;ll share the resources I used at the end of this post.</p><h4 id=useful-links>Useful links:<a hidden class=anchor aria-hidden=true href=#useful-links>#</a></h4><p><a href=https://doc.rust-lang.org/book/>Rust Book</a></p><p><a href=https://en.wikipedia.org/wiki/Base64>What is Base64?</a></p><h2 id=theory>Theory<a hidden class=anchor aria-hidden=true href=#theory>#</a></h2><p>Now, let&rsquo;s dive into the theoretical aspects of how base64 works. By the end of this section, we&rsquo;ll be able to manually encode data to base64 using pen and paper.</p><p>The steps to encode a set of characters to base64 are as follows:</p><ol><li>Split the input, typically a sequence of bytes, into groups of three bytes.</li><li>Each group of three bytes corresponds to a total of 24 bits.</li><li>Split the 24 bits into four 6-bit groups.</li><li>Map each 6-bit group to its corresponding base64 character from the character set: A-Z, a-z, 0-9, +, and /.</li><li>If the number of bytes is not divisible by three, add the padding character &lsquo;=&rsquo;.</li></ol><p>Let&rsquo;s illustrate this process by manually converting the text &lsquo;Rust&rsquo; into base64.</p><ol><li>Split the input into groups of three bytes:</li></ol><p><img src=/img/base64/1.png alt="step one"></p><ol start=2><li>In the next step, we combine the binary values and split them into four 6-bit groups:</li></ol><p><img src=/img/base64/2.png alt="step two"></p><ol start=3><li>Now, let&rsquo;s map each group to its corresponding character using the standard base64 character mapping based on RFC4648 (image from <a href=https://en.wikipedia.org/wiki/Base64>Wikipedia</a>):</li></ol><p><img src=/img/base64/3.png alt="step three"></p><ol start=4><li>The base64 output for &lsquo;Rus&rsquo; is as follows:</li></ol><p><img src=/img/base64/4.png alt="step three"></p><ol start=5><li>Next, we continue the same steps for the remaining text. In our case, the only character left is &rsquo;t&rsquo;, which would be encoded as follows:</li></ol><p><img src=/img/base64/5.png alt="step three"></p><p>Note that if the last group doesn&rsquo;t have enough bits, we fill it with 0s until it reaches 6 bits in length.</p><p>Adding padding:</p><p>So far, our output is <code>UnVzdA</code>, but because it&rsquo;s not divisible by 3, we need to add the padding character <code>=</code> until it becomes divisible by three.</p><p>To calculate how many paddings we need, use the following formula:</p><pre tabindex=0><code>r = len(input) % 3
</code></pre><ul><li><strong>if <code>r</code> is equal to 1</strong>: we need to add two paddings</li><li><strong>if <code>r</code> is equal to 2</strong>: we need to add one padding</li><li><strong>if <code>r</code> is equal to 0</strong>: no paddings needed</li></ul><p>Since the <code>4 % 3 = 1</code> we need to add two paddings at the end and the final output would be <code>UnVzdA==</code>.</p><p>Now that we understand the manual conversion process, let&rsquo;s implement these steps in Rust.</p><h2 id=implementation>Implementation:<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h2><p>We&rsquo;ll start by creating a function called <code>encode</code> in a file named <code>base64.rs</code> that takes a series of bytes as input and returns the encoded output as a string:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// file base64.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>encode</span>(input: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u8</span>]) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> BASE_CHARS: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u8</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>b&#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> output <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> input_len <span style=color:#f92672>=</span> input.len();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>input_len).step_by(<span style=color:#ae81ff>3</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> input.get(i).unwrap();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> input.get(i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>).unwrap_or(<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> input.get(i <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>).unwrap_or(<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> enc1 <span style=color:#f92672>=</span> (a <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> enc2 <span style=color:#f92672>=</span> (((a <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x3</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>4</span>) <span style=color:#f92672>|</span> (b <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>4</span>)) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> enc3 <span style=color:#f92672>=</span> (((b <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xf</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>|</span> (c <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>6</span>)) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> enc4 <span style=color:#f92672>=</span> (c <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x3f</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        output.push(BASE_CHARS[enc1]);
</span></span><span style=display:flex><span>        output.push(BASE_CHARS[enc2]);
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>        output.push(BASE_CHARS[enc3]);
</span></span><span style=display:flex><span>        output.push(BASE_CHARS[enc4]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> output_len <span style=color:#f92672>=</span> output.len();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> padding_len <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> input_len <span style=color:#f92672>%</span> <span style=color:#ae81ff>3</span> {
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>1</span> <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>2</span>, <span style=color:#75715e>// Add two padding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#ae81ff>2</span> <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>1</span>, <span style=color:#75715e>// Add one paddings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        _ <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>0</span>, <span style=color:#75715e>// No paddings needed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>padding_len {
</span></span><span style=display:flex><span>        output[output_len <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> i] <span style=color:#f92672>=</span> <span style=color:#e6db74>b&#39;=&#39;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    String::from_utf8(output).unwrap()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>In the <code>for</code> loop we retrieve the first three byte of the <code>input</code>. Note that the first index is always present but the second and thrid index might be missing. That&rsquo;s why we used <code>unwrap_or(&0)</code>.</li></ul><p>For each group, we perform the necessary bitwise operations to obtain the corresponding base64 characters.</p><ul><li><p>In the line <code>let enc1 = (a >> 2) as usize;</code>, we use the right shift operator (&#187;) to remove the last two bits (MSB) from the variable <code>a</code>. The binary representation of character <code>R</code> is <code>01010010</code> and by shifting it two times to the right the result is: <code>010100</code></p></li><li><p>in the next line <code>let enc2 = (((a & 0x3) &lt;&lt; 4) | (b >> 4)) as usize;</code>, first we extract the last two bits of <code>a</code> by <code>&</code>ing it with <code>0x3</code> (11 in binary), then shift it four times to left and combine the value with first four bits of <code>b</code>. The <code>enc2</code> has the value of <code>100111</code></p></li><li><p>Then we have <code>let enc3 = (((b & 0xf) &lt;&lt; 2) | (c >> 6)) as usize;</code> which extracts the last four bits of <code>b</code>, shift it two times to right and combine the result with first two bits of <code>c</code> which gives us the values of <code>010101</code></p></li><li><p>and finally, <code>let enc4 = (c & 0x3f) as usize;</code> which extracts the remaining bytes from <code>c</code> by &ing it with <code>0x3f</code> (1111 in binary). The <code>enc4</code> is equal to <code>110011</code> in binary.</p></li><li><p>At the end of the <code>for</code> loop we obtain the corresponding base64 characters from <code>BASE_CHARS</code> and push it to output vector.</p></li></ul><p>We are not done yet, we need to check if the padding is necessary or not:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> output_len <span style=color:#f92672>=</span> output.len();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> padding_len <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> input_len <span style=color:#f92672>%</span> <span style=color:#ae81ff>3</span> {
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>1</span> <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>2</span>, <span style=color:#75715e>// Add two padding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#ae81ff>2</span> <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>1</span>, <span style=color:#75715e>// Add one paddings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        _ <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>0</span>, <span style=color:#75715e>// No paddings needed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>padding_len {
</span></span><span style=display:flex><span>        output[output_len <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> i] <span style=color:#f92672>=</span> <span style=color:#e6db74>b&#39;=&#39;</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>This section of the code determines the number of padding characters required and adds them to the end of the output.</p><h2 id=testing>Testing<a hidden class=anchor aria-hidden=true href=#testing>#</a></h2><p>Let&rsquo;s write some test to test our algorithm.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>super</span>::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_encode</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> encoded <span style=color:#f92672>=</span> encode(<span style=color:#e6db74>b&#34;Rust&#34;</span>);
</span></span><span style=display:flex><span>        assert_eq!(<span style=color:#e6db74>&#34;UnVzdA==&#34;</span>, encoded);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>encode_has_padding</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> encoded <span style=color:#f92672>=</span> encode(<span style=color:#e6db74>b&#34;Rust&#34;</span>);
</span></span><span style=display:flex><span>        assert!(encoded.ends_with(<span style=color:#e6db74>&#34;==&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>and the result:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>
</span></span><span style=display:flex><span>running <span style=color:#ae81ff>2</span> tests
</span></span><span style=display:flex><span>test base64::tests::encode_has_padding ... ok
</span></span><span style=display:flex><span>test base64::tests::test_encode ... ok
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test result: ok. <span style=color:#ae81ff>2</span> passed; <span style=color:#ae81ff>0</span> failed; <span style=color:#ae81ff>0</span> ignored; <span style=color:#ae81ff>0</span> measured; <span style=color:#ae81ff>0</span> filtered out; finished in 0.00s
</span></span></code></pre></div><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>In this post, we achieved two goals simultaneously: understanding the base64 encoding algorithm and gained knowledge about Rust. For me, the <code>step_by</code> function, bitwise operators, and <code>unwrap_or</code> method were particularly new and useful. You can use these resources, or any others you prefer, to learn more about base64 and Rust. It&rsquo;s a great exercise to try implementing the base64 decoding algorithm.</p><h3 id=resources>resources<a hidden class=anchor aria-hidden=true href=#resources>#</a></h3><ul><li><p><a href=http://www.sunshine2k.de/articles/coding/base64/understanding_base64.html>http://www.sunshine2k.de/articles/coding/base64/understanding_base64.html</a></p></li><li><p><a href=https://en.wikibooks.org/wiki/Algorithm_Implementation/Miscellaneous/Base64#Javascript_2>https://en.wikibooks.org/wiki/Algorithm_Implementation/Miscellaneous/Base64#Javascript_2</a></p></li><li><p><a href=https://www.rapidtables.com/convert/number/hex-to-binary.html>https://www.rapidtables.com/convert/number/hex-to-binary.html</a></p></li><li><p><a href=https://en.wikipedia.org/wiki/Base64>https://en.wikipedia.org/wiki/Base64</a></p></li><li><p><a href=https://base64.guru/learn/base64-algorithm/encode>https://base64.guru/learn/base64-algorithm/encode</a></p></li><li><p>ChatGPT</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://keyboardsmash.dev/tags/rust/>rust</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://keyboardsmash.dev>Saeed's Blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById("menu").scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById("menu").scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>