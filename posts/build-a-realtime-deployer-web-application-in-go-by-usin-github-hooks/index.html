<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Build a Realtime Deployer Web Application in Go by Usin Github Hooks | Saeed's Blog</title><meta name=keywords content="go"><meta name=description content="I&rsquo;m sure you&rsquo;re agree with me that real-time web apps are so intersting and somehow challenging. In my journey to learn Go, this time, I decided to create a real-time web application. This project would be a simple deployer which works with Github webhooks."><meta name=author content="Saeed"><link rel=canonical href=https://smoqadam.me/posts/build-a-realtime-deployer-web-application-in-go-by-usin-github-hooks/><meta name=google-site-verification content="XYZabc"><link href=/assets/css/stylesheet.min.3839cf02b87f30309470412461116907caabd1b3ec3f5d015df618da2d034992.css integrity="sha256-ODnPArh/MDCUcEEkYRFpB8qr0bPsP10BXfYY2i0DSZI=" rel="preload stylesheet" as=style><link rel=icon href=https://smoqadam.me/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://smoqadam.me/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://smoqadam.me/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://smoqadam.me/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://smoqadam.me/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.74.3"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-123-45','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Build a Realtime Deployer Web Application in Go by Usin Github Hooks"><meta property="og:description" content="I&rsquo;m sure you&rsquo;re agree with me that real-time web apps are so intersting and somehow challenging. In my journey to learn Go, this time, I decided to create a real-time web application. This project would be a simple deployer which works with Github webhooks."><meta property="og:type" content="article"><meta property="og:url" content="https://smoqadam.me/posts/build-a-realtime-deployer-web-application-in-go-by-usin-github-hooks/"><meta property="article:published_time" content="2020-04-11T16:58:01+08:00"><meta property="article:modified_time" content="2020-04-11T16:58:01+08:00"><meta property="og:site_name" content="Saeed's blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Build a Realtime Deployer Web Application in Go by Usin Github Hooks"><meta name=twitter:description content="I&rsquo;m sure you&rsquo;re agree with me that real-time web apps are so intersting and somehow challenging. In my journey to learn Go, this time, I decided to create a real-time web application. This project would be a simple deployer which works with Github webhooks."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://smoqadam.me/posts/"},{"@type":"ListItem","position":3,"name":"Build a Realtime Deployer Web Application in Go by Usin Github Hooks","item":"https://smoqadam.me/posts/build-a-realtime-deployer-web-application-in-go-by-usin-github-hooks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Build a Realtime Deployer Web Application in Go by Usin Github Hooks","name":"Build a Realtime Deployer Web Application in Go by Usin Github Hooks","description":"I\u0026amp;rsquo;m sure you\u0026amp;rsquo;re agree with me that real-time web apps are so intersting and somehow challenging. In my journey to learn Go, this time, I decided to create a real-time …","keywords":["go"],"articleBody":"I’m sure you’re agree with me that real-time web apps are so intersting and somehow challenging. In my journey to learn Go, this time, I decided to create a real-time web application. This project would be a simple deployer which works with Github webhooks.\nAt the end of this article, we will learn:\n How to create a web app by mux/router How to use gorilla/websocket to send/receive data to/from client How to use HTML5 websocket API to send/receive data to/from server How to parse YAML and JSON How to use Github webhooks  I’m already get excited, let’s start.\nPrerequisites  Basic knowledge of Go Go must be installed in your machine Basic knowledge of JavaScript GitHub account  Table of content What do we expect from this project? It’s good to know what we should expect at the end of this project. Here is a short description. We have a project in GitHub and we need a project to automate our deployment proccess whenever someone push something to the master branch. It should send a request to a URL (apparantly in our sever) and this project is going to run a several commands on the server.\nFor this purpose, we are going to take advantage of GitHub webhooks which sends a request to a URL with a bunch of data about the change that just made into the repository. The webhook can trigger after push, merge, pull requests and etc. For the sake of simplicity we just use push event for this tutorial.\nRead more about Webhooks\nConfigure GitHub webhooks For using Webhooks, first, we need to enable and configure it for our repository. Open your github repository page and chose the Webhooks from the left sidebar. After click on Add webhook you will see the following page:\n Payload URL: The URL we want to send the request Secret: A secret key to authorize incoming request Which events would you like to trigger this webhook?: In this section you can chose push or another events. For this tutorial we will go with only push event.  And at the end, by selecting Active and Add Webhook this webhook will be enabled for our repository. Which means, everytime we push to the repository, GitHub will send a request to Payload URL.\nCreate a project and install needed packages Create a new directory called whatever you want:\n$ mkdir deployer \u0026\u0026 cd deployer The only library we need is Yaml parser because we want to store some configuration in it.\ngo get github.com/go-yaml/yaml Deployer Configuration It’s better to have a config file to have more control over our application. To acheive this, we are going to store configuration in Yaml file. Create a config.yaml in your root directory:\nprojects: - name: \"smoqadam/blog\" dir: \"/home/saeed/projects/blog\" commands: - git status - git pull origin master - git submodule sync - git submodule update - hugo onFailure: ./notif.sh Here is our configuration. It has a projects array, name of the repository, the path and the commands you want to run, and onFailure which runs whenever something goes wrong in the commands section.\nThat’s all, let’s parse this file with the help of the go-yaml package. Create a file and call it config.go with the following contents:\npackage main import ( \"io/ioutil\" \"gopkg.in/yaml.v2\" ) type Project struct { Name string `yaml:\"name\"` Dir string `yaml:\"dir\"` Commands []string `yaml:\"commands\"` OnFailure string `yaml:\"onFailure\"` } type Config struct { Projects []*Project `yaml:\"projects,omitempty\"` } func NewConfig(path string) (*Config, error) { c := \u0026Config{} y, err := ioutil.ReadFile(path) if err != nil { return c, err } yaml.Unmarshal(y, \u0026c) return c, nil } First we read the file then parse it with yaml.Unmarshal and return the struct.\nParse incoming request Whenever an event triggers, github will send a request to Payload URL with a bunch of information about the repository in Json format.\nCreate a file and call it payload.go:\npackage main import ( \"encoding/json\" ) type Author struct { Name string `json:\"name\"` Email string `json:\"email\"` Username string `json:\"username\"` } type Commit struct { ID string `json:\"id\"` // commit message \tMessage string `json:\"message\"` // commit author  Authod Author `json:\"author\"` // list of the files that added to the repo  Added []string `json:\"added\"` // list of the files removed from the repo  Removed []string `json:\"removed\"` // list of the files modified in the repo \tModified []string `json:\"modified\"` } type Repository struct { // repository name e.g. username/repo \tName string `json:\"full_name\"` } type Payload struct { Repo Repository `json:\"repository\"` Commits []Commit `json:\"commits\"` } func NewPayload(input []byte) (*Payload, error) { p := \u0026Payload{} if err := json.Unmarshal(input, \u0026p); err != nil { return p, err } return p, nil } Payload struct has two fields, Repo that store information about the repository and the Commits that store array of Commit struct.\nCreate route To handle webhooks, we need a route and we are going to use built in http library.\nCreate main.go file with the following content:\npackage main import ( \"fmt\" \"io/ioutil\" \"log\" \"net/http\" \"os\" \"time\" ) func main() { http.HandleFunc(\"/deploy\", deployHandler) log.Fatalln(http.ListenAndServe(\":3000\", nil)) } func deployHandler(w http.ResponseWriter, r *http.Request) { // parse config file as soon as the request received \tconfig, err := NewConfig(\"./config.yaml\") if err != nil { panic(err) } // read the request body and parse the payload \tp, err := ioutil.ReadAll(r.Body) if err != nil { log.Fatalln(err) } payload, err := NewPayload(p) if err != nil { log.Fatalln(err) } // // get the project config  // project := config.getProject(payload.Repo.Name)  // deployer, _ := NewDeployer(project.Commands) \t// if err := deployer.run(); err != nil { \t// logger(\"Failed\", []byte(err.Error()), \"./error.log\") \t// deployer.exec(project.OnFailure, project.Dir) \t// } } deployHandler is the function that runs everytime any request comes to /deploy route. Inside the function, first we read the config.yaml file because later, we can change the config without to restart the application.\nioutil.ReadAll reads the request body and returns a []byte which we passed it the NewPayload function.\nRunner to handle and execute all commands inside commands array in config.yaml, we will create a struct called Runner. This struct receives a slice of commands and runs them one by one.\nAnyway, create a file and call it runner.go:\n","wordCount":"1020","inLanguage":"en","datePublished":"2020-04-11T16:58:01+08:00","dateModified":"2020-04-11T16:58:01+08:00","author":{"@type":"Person","name":"Saeed"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://smoqadam.me/posts/build-a-realtime-deployer-web-application-in-go-by-usin-github-hooks/"},"publisher":{"@type":"Organization","name":"Saeed's Blog","logo":{"@type":"ImageObject","url":"https://smoqadam.me/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://smoqadam.me accesskey=h title="Saeed's Blog (Alt + H)">Saeed's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://smoqadam.me/about title=About><span>About</span></a></li><li><a href=https://smoqadam.me/categories/ title=categories><span>categories</span></a></li><li><a href=https://smoqadam.me/tags/ title=tags><span>tags</span></a></li><li><a href=https://ideasfor.dev title=Ideasfor.dev><span>Ideasfor.dev</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Build a Realtime Deployer Web Application in Go by Usin Github Hooks<div class=entry-isdraft><sup>&nbsp;&nbsp;[draft]</sup></div></h1><div class=post-meta>April 11, 2020&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Saeed</div></header><div class=post-content><p>I&rsquo;m sure you&rsquo;re agree with me that real-time web apps are so intersting and somehow challenging. In my journey to learn Go, this time, I decided to create a real-time web application. This project would be a simple deployer which works with Github webhooks.</p><p>At the end of this article, we will learn:</p><ul><li>How to create a web app by mux/router</li><li>How to use gorilla/websocket to send/receive data to/from client</li><li>How to use HTML5 websocket API to send/receive data to/from server</li><li>How to parse YAML and JSON</li><li>How to use Github webhooks</li></ul><p>I&rsquo;m already get excited, let&rsquo;s start.</p><h3 id=prerequisites>Prerequisites<a hidden class=anchor aria-hidden=true href=#prerequisites>#</a></h3><ul><li>Basic knowledge of Go</li><li>Go must be installed in your machine</li><li>Basic knowledge of JavaScript</li><li>GitHub account</li></ul><h2 id=table-of-content>Table of content<a hidden class=anchor aria-hidden=true href=#table-of-content>#</a></h2><h2 id=what-do-we-expect-from-this-project>What do we expect from this project?<a hidden class=anchor aria-hidden=true href=#what-do-we-expect-from-this-project>#</a></h2><p>It&rsquo;s good to know what we should expect at the end of this project. Here is a short description.
We have a project in GitHub and we need a project to automate our deployment proccess whenever someone <strong>push</strong> something to the master branch. It should send a request to a URL (apparantly in our sever) and this project is going to run a several commands on the server.</p><p>For this purpose, we are going to take advantage of GitHub webhooks which sends a request to a URL with a bunch of data about the change that just made into the repository. The webhook can trigger after <code>push</code>, <code>merge</code>, <code>pull requests</code> and etc. For the sake of simplicity we just use <code>push</code> event for this tutorial.</p><p><a href=https://developer.github.com/webhooks/>Read more about Webhooks</a></p><h2 id=configure-github-webhooks>Configure GitHub webhooks<a hidden class=anchor aria-hidden=true href=#configure-github-webhooks>#</a></h2><p>For using Webhooks, first, we need to enable and configure it for our repository. Open your github repository page and chose the Webhooks from the left sidebar. After click on Add webhook you will see the following page:</p><ul><li>Payload URL: The URL we want to send the request</li><li>Secret: A secret key to authorize incoming request</li><li>Which events would you like to trigger this webhook?: In this section you can chose <code>push</code> or another events. For this tutorial we will go with only <code>push</code> event.</li></ul><p>And at the end, by selecting <code>Active</code> and <code>Add Webhook</code> this webhook will be enabled for our repository. Which means, everytime we <code>push</code> to the repository, GitHub will send a request to Payload URL.</p><h2 id=create-a-project-and-install-needed-packages>Create a project and install needed packages<a hidden class=anchor aria-hidden=true href=#create-a-project-and-install-needed-packages>#</a></h2><p>Create a new directory called whatever you want:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ mkdir deployer <span style=color:#f92672>&amp;&amp;</span> cd deployer
</code></pre></div><p>The only library we need is Yaml parser because we want to store some configuration in it.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>go get github.com/go-yaml/yaml
</code></pre></div><h2 id=deployer-configuration>Deployer Configuration<a hidden class=anchor aria-hidden=true href=#deployer-configuration>#</a></h2><p>It&rsquo;s better to have a config file to have more control over our application. To acheive this, we are going to store configuration in Yaml file. Create a <code>config.yaml</code> in your root directory:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#66d9ef>projects</span>:
    - <span style=color:#66d9ef>name</span>: <span style=color:#e6db74>&#34;smoqadam/blog&#34;</span> 
      <span style=color:#66d9ef>dir</span>: <span style=color:#e6db74>&#34;/home/saeed/projects/blog&#34;</span>
      <span style=color:#66d9ef>commands</span>:
        - git status
        - git pull origin master
        - git submodule sync
        - git submodule update
        - hugo
      <span style=color:#66d9ef>onFailure</span>: ./notif.sh
</code></pre></div><p>Here is our configuration. It has a projects array, <code>name</code> of the repository, the path and the commands you want to run, and <code>onFailure</code> which runs whenever something goes wrong in the <code>commands</code> section.</p><p>That&rsquo;s all, let&rsquo;s parse this file with the help of the <code>go-yaml</code> package. Create a file and call it <code>config.go</code> with the following contents:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>
<span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;io/ioutil&#34;</span>

	<span style=color:#e6db74>&#34;gopkg.in/yaml.v2&#34;</span>
)

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Project</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Name</span>      <span style=color:#66d9ef>string</span>   <span style=color:#e6db74>`yaml:&#34;name&#34;`</span>
	<span style=color:#a6e22e>Dir</span>       <span style=color:#66d9ef>string</span>   <span style=color:#e6db74>`yaml:&#34;dir&#34;`</span>
	<span style=color:#a6e22e>Commands</span>  []<span style=color:#66d9ef>string</span> <span style=color:#e6db74>`yaml:&#34;commands&#34;`</span>
	<span style=color:#a6e22e>OnFailure</span> <span style=color:#66d9ef>string</span>   <span style=color:#e6db74>`yaml:&#34;onFailure&#34;`</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Config</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Projects</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>Project</span> <span style=color:#e6db74>`yaml:&#34;projects,omitempty&#34;`</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewConfig</span>(<span style=color:#a6e22e>path</span> <span style=color:#66d9ef>string</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Config</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Config</span>{}
	<span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>ReadFile</span>(<span style=color:#a6e22e>path</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>err</span>
	}
	<span style=color:#a6e22e>yaml</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>y</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>, <span style=color:#66d9ef>nil</span>
}

</code></pre></div><p>First we read the file then parse it with <code>yaml.Unmarshal</code> and return the struct.</p><h2 id=parse-incoming-request>Parse incoming request<a hidden class=anchor aria-hidden=true href=#parse-incoming-request>#</a></h2><p>Whenever an event triggers, github will send a request to Payload URL with a bunch of information about the repository in Json format.</p><p>Create a file and call it <code>payload.go</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;encoding/json&#34;</span>
)

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Author</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Name</span>     <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;name&#34;`</span>
	<span style=color:#a6e22e>Email</span>    <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;email&#34;`</span>
	<span style=color:#a6e22e>Username</span> <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;username&#34;`</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Commit</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>ID</span>       <span style=color:#66d9ef>string</span>   <span style=color:#e6db74>`json:&#34;id&#34;`</span>

    <span style=color:#75715e>// commit message
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>Message</span>  <span style=color:#66d9ef>string</span>   <span style=color:#e6db74>`json:&#34;message&#34;`</span>
    
    <span style=color:#75715e>// commit author
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>Authod</span>   <span style=color:#a6e22e>Author</span>   <span style=color:#e6db74>`json:&#34;author&#34;`</span>
    
    <span style=color:#75715e>// list of the files that added to the repo
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>Added</span>    []<span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;added&#34;`</span>
    
    <span style=color:#75715e>// list of the files removed from the repo
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>Removed</span>  []<span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;removed&#34;`</span>
    
    <span style=color:#75715e>// list of the files modified in the repo
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>Modified</span> []<span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;modified&#34;`</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Repository</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#75715e>// repository name e.g. username/repo 
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;full_name&#34;`</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Payload</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Repo</span>    <span style=color:#a6e22e>Repository</span> <span style=color:#e6db74>`json:&#34;repository&#34;`</span>
	<span style=color:#a6e22e>Commits</span> []<span style=color:#a6e22e>Commit</span>   <span style=color:#e6db74>`json:&#34;commits&#34;`</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewPayload</span>(<span style=color:#a6e22e>input</span> []<span style=color:#66d9ef>byte</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Payload</span>, <span style=color:#66d9ef>error</span>) {
	<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Payload</span>{}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>input</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>err</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>, <span style=color:#66d9ef>nil</span>
}

</code></pre></div><p><code>Payload</code> struct has two fields, <code>Repo</code> that store information about the repository and the <code>Commits</code> that store array of <code>Commit</code> struct.</p><h2 id=create-route>Create route<a hidden class=anchor aria-hidden=true href=#create-route>#</a></h2><p>To handle webhooks, we need a route and we are going to use built in <code>http</code> library.</p><p>Create <code>main.go</code> file with the following content:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>
<span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;fmt&#34;</span>
	<span style=color:#e6db74>&#34;io/ioutil&#34;</span>
	<span style=color:#e6db74>&#34;log&#34;</span>
	<span style=color:#e6db74>&#34;net/http&#34;</span>
	<span style=color:#e6db74>&#34;os&#34;</span>
	<span style=color:#e6db74>&#34;time&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {

	<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/deploy&#34;</span>, <span style=color:#a6e22e>deployHandler</span>)

	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalln</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:3000&#34;</span>, <span style=color:#66d9ef>nil</span>))
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>deployHandler</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {

    <span style=color:#75715e>// parse config file as soon as the request received
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>config</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewConfig</span>(<span style=color:#e6db74>&#34;./config.yaml&#34;</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		panic(<span style=color:#a6e22e>err</span>)
	}

    <span style=color:#75715e>// read the request body and parse the payload
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>ReadAll</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Body</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalln</span>(<span style=color:#a6e22e>err</span>)
	}
	<span style=color:#a6e22e>payload</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewPayload</span>(<span style=color:#a6e22e>p</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalln</span>(<span style=color:#a6e22e>err</span>)
	}
    
    <span style=color:#75715e>// // get the project config
</span><span style=color:#75715e></span>    <span style=color:#75715e>// project := config.getProject(payload.Repo.Name)
</span><span style=color:#75715e></span>
	<span style=color:#75715e>// deployer, _ := NewDeployer(project.Commands)
</span><span style=color:#75715e></span>	<span style=color:#75715e>// if err := deployer.run(); err != nil {
</span><span style=color:#75715e></span>	<span style=color:#75715e>// 	logger(&#34;Failed&#34;, []byte(err.Error()), &#34;./error.log&#34;)
</span><span style=color:#75715e></span>	<span style=color:#75715e>// 	deployer.exec(project.OnFailure, project.Dir)
</span><span style=color:#75715e></span>	<span style=color:#75715e>// }
</span><span style=color:#75715e></span>}

</code></pre></div><p><code>deployHandler</code> is the function that runs everytime any request comes to <code>/deploy</code> route. Inside the function, first we read the <code>config.yaml</code> file because later, we can change the config without to restart the application.</p><p><code>ioutil.ReadAll</code> reads the request body and returns a <code>[]byte</code> which we passed it the <code>NewPayload</code> function.</p><h2 id=runner>Runner<a hidden class=anchor aria-hidden=true href=#runner>#</a></h2><p>to handle and execute all commands inside <code>commands</code> array in <code>config.yaml</code>, we will create a struct called Runner. This struct receives a slice of commands and runs them one by one.</p><p>Anyway, create a file and call it <code>runner.go</code>:</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://smoqadam.me/tags/go/>go</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://smoqadam.me>Saeed's Blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>